// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GLTF_H_
#define FLATBUFFERS_GENERATED_GLTF_H_

#include "flatbuffers/flatbuffers.h"

struct glTF;
struct glTFT;

struct glTFT : public flatbuffers::NativeTable
{
	typedef glTF							 TableType;
	static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
	{
		return "glTFT";
	}
	int32_t foobar;
	glTFT() : foobar(0)
	{
	}
};

struct glTF FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
{
	typedef glTFT							 NativeTableType;
	static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
	{
		return "glTF";
	}
	enum
	{
		VT_FOOBAR = 4
	};
	int32_t foobar() const
	{
		return GetField<int32_t>(VT_FOOBAR, 0);
	}
	bool mutate_foobar(int32_t _foobar)
	{
		return SetField<int32_t>(VT_FOOBAR, _foobar, 0);
	}
	bool Verify(flatbuffers::Verifier& verifier) const
	{
		return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_FOOBAR) && verifier.EndTable();
	}
	glTFT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
	void UnPackTo(glTFT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
	static flatbuffers::Offset<glTF> Pack(flatbuffers::FlatBufferBuilder&		  _fbb,
										  const glTFT*							  _o,
										  const flatbuffers::rehasher_function_t* _rehasher = nullptr);
};

struct glTFBuilder
{
	flatbuffers::FlatBufferBuilder& fbb_;
	flatbuffers::uoffset_t			start_;
	void add_foobar(int32_t foobar)
	{
		fbb_.AddElement<int32_t>(glTF::VT_FOOBAR, foobar, 0);
	}
	glTFBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
	{
		start_ = fbb_.StartTable();
	}
	glTFBuilder&			  operator=(const glTFBuilder&);
	flatbuffers::Offset<glTF> Finish()
	{
		const auto end = fbb_.EndTable(start_, 1);
		auto	   o   = flatbuffers::Offset<glTF>(end);
		return o;
	}
};

inline flatbuffers::Offset<glTF> CreateglTF(flatbuffers::FlatBufferBuilder& _fbb, int32_t foobar = 0)
{
	glTFBuilder builder_(_fbb);
	builder_.add_foobar(foobar);
	return builder_.Finish();
}

flatbuffers::Offset<glTF> CreateglTF(flatbuffers::FlatBufferBuilder&		 _fbb,
									 const glTFT*							 _o,
									 const flatbuffers::rehasher_function_t* _rehasher = nullptr);

inline glTFT* glTF::UnPack(const flatbuffers::resolver_function_t* _resolver) const
{
	auto _o = new glTFT();
	UnPackTo(_o, _resolver);
	return _o;
}

inline void glTF::UnPackTo(glTFT* _o, const flatbuffers::resolver_function_t* _resolver) const
{
	(void)_o;
	(void)_resolver;
	{
		auto _e	= foobar();
		_o->foobar = _e;
	};
}

inline flatbuffers::Offset<glTF> glTF::Pack(flatbuffers::FlatBufferBuilder& _fbb, const glTFT* _o, const flatbuffers::rehasher_function_t* _rehasher)
{
	return CreateglTF(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<glTF> CreateglTF(flatbuffers::FlatBufferBuilder& _fbb, const glTFT* _o, const flatbuffers::rehasher_function_t* _rehasher)
{
	(void)_rehasher;
	(void)_o;
	auto _foobar = _o->foobar;
	return CreateglTF(_fbb, _foobar);
}

#endif	// FLATBUFFERS_GENERATED_GLTF_H_
