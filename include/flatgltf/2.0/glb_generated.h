// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GLB_GLTF_2_0_GLB_H_
#define FLATBUFFERS_GENERATED_GLB_GLTF_2_0_GLB_H_

#include "flatbuffers/flatbuffers.h"
#include "flatbuffers/flexbuffers.h"

namespace glTF_2_0
{
	namespace glb
	{

		struct Header;

		struct JSONChunk;
		struct JSONChunkT;

		struct BinaryChunk;
		struct BinaryChunkT;

		struct glTF_B;
		struct glTF_BT;

		MANUALLY_ALIGNED_STRUCT(4) Header FLATBUFFERS_FINAL_CLASS
		{
		private:
			uint32_t magic_;
			uint32_t version_;
			uint32_t length_;

		public:
			static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
			{
				return "glTF_2_0.glb.Header";
			}
			Header()
			{
				memset(this, 0, sizeof(Header));
			}
			Header(const Header& _o)
			{
				memcpy(this, &_o, sizeof(Header));
			}
			Header(uint32_t _magic, uint32_t _version, uint32_t _length)
				: magic_(flatbuffers::EndianScalar(_magic))
				, version_(flatbuffers::EndianScalar(_version))
				, length_(flatbuffers::EndianScalar(_length))
			{
			}
			/// magic equals 0x46546C67. It is ASCII string 'glTF', and can be used to identify data as Binary glTF.
			uint32_t magic() const
			{
				return flatbuffers::EndianScalar(magic_);
			}
			void mutate_magic(uint32_t _magic)
			{
				flatbuffers::WriteScalar(&magic_, _magic);
			}
			/// version indicates the version of the Binary glTF container format. This specification defines version 2.
			uint32_t version() const
			{
				return flatbuffers::EndianScalar(version_);
			}
			void mutate_version(uint32_t _version)
			{
				flatbuffers::WriteScalar(&version_, _version);
			}
			/// length is the total length of the Binary glTF, including Header and all Chunks, in bytes.
			uint32_t length() const
			{
				return flatbuffers::EndianScalar(length_);
			}
			void mutate_length(uint32_t _length)
			{
				flatbuffers::WriteScalar(&length_, _length);
			}
		};
		STRUCT_END(Header, 12);

		struct JSONChunkT : public flatbuffers::NativeTable
		{
			typedef JSONChunk						 TableType;
			static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
			{
				return "glTF_2_0.glb.JSONChunkT";
			}
			uint32_t			 chunkLength;
			uint32_t			 chunkType;
			std::vector<uint8_t> chunkData;
			JSONChunkT() : chunkLength(0), chunkType(1313821514)
			{
			}
		};

		struct JSONChunk FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
		{
			typedef JSONChunkT						 NativeTableType;
			static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
			{
				return "glTF_2_0.glb.JSONChunk";
			}
			enum
			{
				VT_CHUNKLENGTH = 4,
				VT_CHUNKTYPE   = 6,
				VT_CHUNKDATA   = 8
			};
			/// chunkLength is the length of chunkData, in bytes.
			/// NOTE: must be modulo 4
			uint32_t chunkLength() const
			{
				return GetField<uint32_t>(VT_CHUNKLENGTH, 0);
			}
			bool mutate_chunkLength(uint32_t _chunkLength)
			{
				return SetField<uint32_t>(VT_CHUNKLENGTH, _chunkLength, 0);
			}
			/// chunkType indicates the type of chunk. See Table 1 for details.
			/// chunkType equals 0x4E4F534A, ASCII string 'JSON'
			uint32_t chunkType() const
			{
				return GetField<uint32_t>(VT_CHUNKTYPE, 1313821514);
			}
			bool mutate_chunkType(uint32_t _chunkType)
			{
				return SetField<uint32_t>(VT_CHUNKTYPE, _chunkType, 1313821514);
			}
			/// chunkData is a json payload of chunk.
			/// must be padded with 0x20/[space] to fit alignment
			const flatbuffers::Vector<uint8_t>* chunkData() const
			{
				return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_CHUNKDATA);
			}
			flatbuffers::Vector<uint8_t>* mutable_chunkData()
			{
				return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_CHUNKDATA);
			}
			const glTF_2_0::glb::Root* chunkData_nested_root() const
			{
				auto data = chunkData()->Data();
				return flatbuffers::GetRoot<glTF_2_0::glb::Root>(data);
			}
			bool Verify(flatbuffers::Verifier& verifier) const
			{
				return VerifyTableStart(verifier) && VerifyField<uint32_t>(verifier, VT_CHUNKLENGTH)
					   && VerifyField<uint32_t>(verifier, VT_CHUNKTYPE) && VerifyOffset(verifier, VT_CHUNKDATA)
					   && verifier.Verify(chunkData()) && verifier.EndTable();
			}
			JSONChunkT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
			void UnPackTo(JSONChunkT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
			static flatbuffers::Offset<JSONChunk> Pack(flatbuffers::FlatBufferBuilder&		   _fbb,
													   const JSONChunkT*					   _o,
													   const flatbuffers::rehasher_function_t* _rehasher = nullptr);
		};

		struct JSONChunkBuilder
		{
			flatbuffers::FlatBufferBuilder& fbb_;
			flatbuffers::uoffset_t			start_;
			void add_chunkLength(uint32_t chunkLength)
			{
				fbb_.AddElement<uint32_t>(JSONChunk::VT_CHUNKLENGTH, chunkLength, 0);
			}
			void add_chunkType(uint32_t chunkType)
			{
				fbb_.AddElement<uint32_t>(JSONChunk::VT_CHUNKTYPE, chunkType, 1313821514);
			}
			void add_chunkData(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> chunkData)
			{
				fbb_.AddOffset(JSONChunk::VT_CHUNKDATA, chunkData);
			}
			JSONChunkBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
			{
				start_ = fbb_.StartTable();
			}
			JSONChunkBuilder&			   operator=(const JSONChunkBuilder&);
			flatbuffers::Offset<JSONChunk> Finish()
			{
				const auto end = fbb_.EndTable(start_, 3);
				auto	   o   = flatbuffers::Offset<JSONChunk>(end);
				return o;
			}
		};

		inline flatbuffers::Offset<JSONChunk> CreateJSONChunk(flatbuffers::FlatBufferBuilder& _fbb,
															  uint32_t						  chunkLength = 0,
															  uint32_t						  chunkType   = 1313821514,
															  flatbuffers::Offset<flatbuffers::Vector<uint8_t>> chunkData = 0)
		{
			JSONChunkBuilder builder_(_fbb);
			builder_.add_chunkData(chunkData);
			builder_.add_chunkType(chunkType);
			builder_.add_chunkLength(chunkLength);
			return builder_.Finish();
		}

		inline flatbuffers::Offset<JSONChunk> CreateJSONChunkDirect(flatbuffers::FlatBufferBuilder& _fbb,
																	uint32_t						chunkLength = 0,
																	uint32_t					chunkType = 1313821514,
																	const std::vector<uint8_t>* chunkData = nullptr)
		{
			return glTF_2_0::glb::CreateJSONChunk(_fbb, chunkLength, chunkType, chunkData ? _fbb.CreateVector<uint8_t>(*chunkData) : 0);
		}

		flatbuffers::Offset<JSONChunk> CreateJSONChunk(flatbuffers::FlatBufferBuilder&		   _fbb,
													   const JSONChunkT*					   _o,
													   const flatbuffers::rehasher_function_t* _rehasher = nullptr);

		struct BinaryChunkT : public flatbuffers::NativeTable
		{
			typedef BinaryChunk						 TableType;
			static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
			{
				return "glTF_2_0.glb.BinaryChunkT";
			}
			uint32_t			 chunkLength;
			uint32_t			 chunkType;
			std::vector<uint8_t> chunkData;
			BinaryChunkT() : chunkLength(0), chunkType(5130562)
			{
			}
		};

		struct BinaryChunk FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
		{
			typedef BinaryChunkT					 NativeTableType;
			static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
			{
				return "glTF_2_0.glb.BinaryChunk";
			}
			enum
			{
				VT_CHUNKLENGTH = 4,
				VT_CHUNKTYPE   = 6,
				VT_CHUNKDATA   = 8
			};
			/// chunkLength is the length of chunkData, in bytes.
			/// NOTE: must be modulo 4
			uint32_t chunkLength() const
			{
				return GetField<uint32_t>(VT_CHUNKLENGTH, 0);
			}
			bool mutate_chunkLength(uint32_t _chunkLength)
			{
				return SetField<uint32_t>(VT_CHUNKLENGTH, _chunkLength, 0);
			}
			/// chunkType indicates the type of chunk. See Table 1 for details.
			/// chunkType equals 0x004E4942	, ASCII string 'BIN'
			uint32_t chunkType() const
			{
				return GetField<uint32_t>(VT_CHUNKTYPE, 5130562);
			}
			bool mutate_chunkType(uint32_t _chunkType)
			{
				return SetField<uint32_t>(VT_CHUNKTYPE, _chunkType, 5130562);
			}
			/// chunkData is a binary/json payload of chunk.
			/// must be padded with 0x00 to fit alignment
			const flatbuffers::Vector<uint8_t>* chunkData() const
			{
				return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_CHUNKDATA);
			}
			flatbuffers::Vector<uint8_t>* mutable_chunkData()
			{
				return GetPointer<flatbuffers::Vector<uint8_t>*>(VT_CHUNKDATA);
			}
			bool Verify(flatbuffers::Verifier& verifier) const
			{
				return VerifyTableStart(verifier) && VerifyField<uint32_t>(verifier, VT_CHUNKLENGTH)
					   && VerifyField<uint32_t>(verifier, VT_CHUNKTYPE) && VerifyOffset(verifier, VT_CHUNKDATA)
					   && verifier.Verify(chunkData()) && verifier.EndTable();
			}
			BinaryChunkT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
			void UnPackTo(BinaryChunkT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
			static flatbuffers::Offset<BinaryChunk> Pack(flatbuffers::FlatBufferBuilder&		 _fbb,
														 const BinaryChunkT*					 _o,
														 const flatbuffers::rehasher_function_t* _rehasher = nullptr);
		};

		struct BinaryChunkBuilder
		{
			flatbuffers::FlatBufferBuilder& fbb_;
			flatbuffers::uoffset_t			start_;
			void add_chunkLength(uint32_t chunkLength)
			{
				fbb_.AddElement<uint32_t>(BinaryChunk::VT_CHUNKLENGTH, chunkLength, 0);
			}
			void add_chunkType(uint32_t chunkType)
			{
				fbb_.AddElement<uint32_t>(BinaryChunk::VT_CHUNKTYPE, chunkType, 5130562);
			}
			void add_chunkData(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> chunkData)
			{
				fbb_.AddOffset(BinaryChunk::VT_CHUNKDATA, chunkData);
			}
			BinaryChunkBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
			{
				start_ = fbb_.StartTable();
			}
			BinaryChunkBuilder&				 operator=(const BinaryChunkBuilder&);
			flatbuffers::Offset<BinaryChunk> Finish()
			{
				const auto end = fbb_.EndTable(start_, 3);
				auto	   o   = flatbuffers::Offset<BinaryChunk>(end);
				return o;
			}
		};

		inline flatbuffers::Offset<BinaryChunk> CreateBinaryChunk(flatbuffers::FlatBufferBuilder& _fbb,
																  uint32_t						  chunkLength = 0,
																  uint32_t						  chunkType   = 5130562,
																  flatbuffers::Offset<flatbuffers::Vector<uint8_t>> chunkData = 0)
		{
			BinaryChunkBuilder builder_(_fbb);
			builder_.add_chunkData(chunkData);
			builder_.add_chunkType(chunkType);
			builder_.add_chunkLength(chunkLength);
			return builder_.Finish();
		}

		inline flatbuffers::Offset<BinaryChunk> CreateBinaryChunkDirect(flatbuffers::FlatBufferBuilder& _fbb,
																		uint32_t						chunkLength = 0,
																		uint32_t					chunkType = 5130562,
																		const std::vector<uint8_t>* chunkData = nullptr)
		{
			return glTF_2_0::glb::CreateBinaryChunk(_fbb, chunkLength, chunkType, chunkData ? _fbb.CreateVector<uint8_t>(*chunkData) : 0);
		}

		flatbuffers::Offset<BinaryChunk> CreateBinaryChunk(flatbuffers::FlatBufferBuilder&		   _fbb,
														   const BinaryChunkT*					   _o,
														   const flatbuffers::rehasher_function_t* _rehasher = nullptr);

		struct glTF_BT : public flatbuffers::NativeTable
		{
			typedef glTF_B							 TableType;
			static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
			{
				return "glTF_2_0.glb.glTF_BT";
			}
			std::unique_ptr<Header>		  header;
			std::unique_ptr<JSONChunkT>   json;
			std::unique_ptr<BinaryChunkT> bin;
			glTF_BT()
			{
			}
		};

		struct glTF_B FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
		{
			typedef glTF_BT							 NativeTableType;
			static FLATBUFFERS_CONSTEXPR const char* GetFullyQualifiedName()
			{
				return "glTF_2_0.glb.glTF_B";
			}
			enum
			{
				VT_HEADER = 4,
				VT_JSON   = 6,
				VT_BIN	= 8
			};
			const Header* header() const
			{
				return GetStruct<const Header*>(VT_HEADER);
			}
			Header* mutable_header()
			{
				return GetStruct<Header*>(VT_HEADER);
			}
			const JSONChunk* json() const
			{
				return GetPointer<const JSONChunk*>(VT_JSON);
			}
			JSONChunk* mutable_json()
			{
				return GetPointer<JSONChunk*>(VT_JSON);
			}
			const BinaryChunk* bin() const
			{
				return GetPointer<const BinaryChunk*>(VT_BIN);
			}
			BinaryChunk* mutable_bin()
			{
				return GetPointer<BinaryChunk*>(VT_BIN);
			}
			bool Verify(flatbuffers::Verifier& verifier) const
			{
				return VerifyTableStart(verifier) && VerifyFieldRequired<Header>(verifier, VT_HEADER)
					   && VerifyOffsetRequired(verifier, VT_JSON) && verifier.VerifyTable(json())
					   && VerifyOffset(verifier, VT_BIN) && verifier.VerifyTable(bin()) && verifier.EndTable();
			}
			glTF_BT* UnPack(const flatbuffers::resolver_function_t* _resolver = nullptr) const;
			void UnPackTo(glTF_BT* _o, const flatbuffers::resolver_function_t* _resolver = nullptr) const;
			static flatbuffers::Offset<glTF_B> Pack(flatbuffers::FlatBufferBuilder&			_fbb,
													const glTF_BT*							_o,
													const flatbuffers::rehasher_function_t* _rehasher = nullptr);
		};

		struct glTF_BBuilder
		{
			flatbuffers::FlatBufferBuilder& fbb_;
			flatbuffers::uoffset_t			start_;
			void add_header(const Header* header)
			{
				fbb_.AddStruct(glTF_B::VT_HEADER, header);
			}
			void add_json(flatbuffers::Offset<JSONChunk> json)
			{
				fbb_.AddOffset(glTF_B::VT_JSON, json);
			}
			void add_bin(flatbuffers::Offset<BinaryChunk> bin)
			{
				fbb_.AddOffset(glTF_B::VT_BIN, bin);
			}
			glTF_BBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb)
			{
				start_ = fbb_.StartTable();
			}
			glTF_BBuilder&				operator=(const glTF_BBuilder&);
			flatbuffers::Offset<glTF_B> Finish()
			{
				const auto end = fbb_.EndTable(start_, 3);
				auto	   o   = flatbuffers::Offset<glTF_B>(end);
				fbb_.Required(o, glTF_B::VT_HEADER);
				fbb_.Required(o, glTF_B::VT_JSON);
				return o;
			}
		};

		inline flatbuffers::Offset<glTF_B> CreateglTF_B(flatbuffers::FlatBufferBuilder&  _fbb,
														const Header*					 header = 0,
														flatbuffers::Offset<JSONChunk>   json   = 0,
														flatbuffers::Offset<BinaryChunk> bin	= 0)
		{
			glTF_BBuilder builder_(_fbb);
			builder_.add_bin(bin);
			builder_.add_json(json);
			builder_.add_header(header);
			return builder_.Finish();
		}

		flatbuffers::Offset<glTF_B> CreateglTF_B(flatbuffers::FlatBufferBuilder&		 _fbb,
												 const glTF_BT*							 _o,
												 const flatbuffers::rehasher_function_t* _rehasher = nullptr);

		inline JSONChunkT* JSONChunk::UnPack(const flatbuffers::resolver_function_t* _resolver) const
		{
			auto _o = new JSONChunkT();
			UnPackTo(_o, _resolver);
			return _o;
		}

		inline void JSONChunk::UnPackTo(JSONChunkT* _o, const flatbuffers::resolver_function_t* _resolver) const
		{
			(void)_o;
			(void)_resolver;
			{
				auto _e			= chunkLength();
				_o->chunkLength = _e;
			};
			{
				auto _e		  = chunkType();
				_o->chunkType = _e;
			};
			{
				auto _e = chunkData();
				if (_e)
				{
					_o->chunkData.resize(_e->size());
					for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
					{
						_o->chunkData[_i] = _e->Get(_i);
					}
				}
			};
		}

		inline flatbuffers::Offset<JSONChunk> JSONChunk::Pack(flatbuffers::FlatBufferBuilder&		  _fbb,
															  const JSONChunkT*						  _o,
															  const flatbuffers::rehasher_function_t* _rehasher)
		{
			return CreateJSONChunk(_fbb, _o, _rehasher);
		}

		inline flatbuffers::Offset<JSONChunk> CreateJSONChunk(flatbuffers::FlatBufferBuilder&		  _fbb,
															  const JSONChunkT*						  _o,
															  const flatbuffers::rehasher_function_t* _rehasher)
		{
			(void)_rehasher;
			(void)_o;
			auto _chunkLength = _o->chunkLength;
			auto _chunkType   = _o->chunkType;
			auto _chunkData   = _o->chunkData.size() ? _fbb.CreateVector(_o->chunkData) : 0;
			return glTF_2_0::glb::CreateJSONChunk(_fbb, _chunkLength, _chunkType, _chunkData);
		}

		inline BinaryChunkT* BinaryChunk::UnPack(const flatbuffers::resolver_function_t* _resolver) const
		{
			auto _o = new BinaryChunkT();
			UnPackTo(_o, _resolver);
			return _o;
		}

		inline void BinaryChunk::UnPackTo(BinaryChunkT* _o, const flatbuffers::resolver_function_t* _resolver) const
		{
			(void)_o;
			(void)_resolver;
			{
				auto _e			= chunkLength();
				_o->chunkLength = _e;
			};
			{
				auto _e		  = chunkType();
				_o->chunkType = _e;
			};
			{
				auto _e = chunkData();
				if (_e)
				{
					_o->chunkData.resize(_e->size());
					for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++)
					{
						_o->chunkData[_i] = _e->Get(_i);
					}
				}
			};
		}

		inline flatbuffers::Offset<BinaryChunk> BinaryChunk::Pack(flatbuffers::FlatBufferBuilder&		  _fbb,
																  const BinaryChunkT*					  _o,
																  const flatbuffers::rehasher_function_t* _rehasher)
		{
			return CreateBinaryChunk(_fbb, _o, _rehasher);
		}

		inline flatbuffers::Offset<BinaryChunk> CreateBinaryChunk(flatbuffers::FlatBufferBuilder&		  _fbb,
																  const BinaryChunkT*					  _o,
																  const flatbuffers::rehasher_function_t* _rehasher)
		{
			(void)_rehasher;
			(void)_o;
			auto _chunkLength = _o->chunkLength;
			auto _chunkType   = _o->chunkType;
			auto _chunkData   = _o->chunkData.size() ? _fbb.CreateVector(_o->chunkData) : 0;
			return glTF_2_0::glb::CreateBinaryChunk(_fbb, _chunkLength, _chunkType, _chunkData);
		}

		inline glTF_BT* glTF_B::UnPack(const flatbuffers::resolver_function_t* _resolver) const
		{
			auto _o = new glTF_BT();
			UnPackTo(_o, _resolver);
			return _o;
		}

		inline void glTF_B::UnPackTo(glTF_BT* _o, const flatbuffers::resolver_function_t* _resolver) const
		{
			(void)_o;
			(void)_resolver;
			{
				auto _e = header();
				if (_e)
					_o->header = std::unique_ptr<Header>(new Header(*_e));
			};
			{
				auto _e = json();
				if (_e)
					_o->json = std::unique_ptr<JSONChunkT>(_e->UnPack(_resolver));
			};
			{
				auto _e = bin();
				if (_e)
					_o->bin = std::unique_ptr<BinaryChunkT>(_e->UnPack(_resolver));
			};
		}

		inline flatbuffers::Offset<glTF_B> glTF_B::Pack(flatbuffers::FlatBufferBuilder&			_fbb,
														const glTF_BT*							_o,
														const flatbuffers::rehasher_function_t* _rehasher)
		{
			return CreateglTF_B(_fbb, _o, _rehasher);
		}

		inline flatbuffers::Offset<glTF_B> CreateglTF_B(flatbuffers::FlatBufferBuilder&			_fbb,
														const glTF_BT*							_o,
														const flatbuffers::rehasher_function_t* _rehasher)
		{
			(void)_rehasher;
			(void)_o;
			auto _header = _o->header ? _o->header.get() : 0;
			auto _json   = _o->json ? CreateJSONChunk(_fbb, _o->json.get(), _rehasher) : 0;
			auto _bin	= _o->bin ? CreateBinaryChunk(_fbb, _o->bin.get(), _rehasher) : 0;
			return glTF_2_0::glb::CreateglTF_B(_fbb, _header, _json, _bin);
		}

	}	// namespace glb

	inline const glTF_2_0::glb::Root* GetRoot(const void* buf)
	{
		return flatbuffers::GetRoot<glTF_2_0::glb::Root>(buf);
	}

	inline Root* GetMutableRoot(void* buf)
	{
		return flatbuffers::GetMutableRoot<Root>(buf);
	}

	inline const char* RootIdentifier()
	{
		return "glTF";
	}

	inline bool RootBufferHasIdentifier(const void* buf)
	{
		return flatbuffers::BufferHasIdentifier(buf, RootIdentifier());
	}

	inline bool VerifyRootBuffer(flatbuffers::Verifier& verifier)
	{
		return verifier.VerifyBuffer<glTF_2_0::glb::Root>(RootIdentifier());
	}

	inline const char* RootExtension()
	{
		return "glf";
	}

	inline void FinishRootBuffer(flatbuffers::FlatBufferBuilder& fbb, flatbuffers::Offset<glTF_2_0::glb::Root> root)
	{
		fbb.Finish(root, RootIdentifier());
	}

	inline std::unique_ptr<RootT> UnPackRoot(const void* buf, const flatbuffers::resolver_function_t* res = nullptr)
	{
		return std::unique_ptr<RootT>(GetRoot(buf)->UnPack(res));
	}

}	// namespace glTF_2_0

#endif	// FLATBUFFERS_GENERATED_GLB_GLTF_2_0_GLB_H_
